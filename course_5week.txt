optimization of our programming.


중요한 것은 알고리즘과 자료구조...
-->실행문이 컴퓨터내부에서 어떻게 실행이 되는지 어떻게 최적화가 되는지에 대해서

(컴퓨터구조에대한 지식이 필요)
최적화된 컴파일러
-레지스터 할당
-중복된 계산회피
-실행되지 않는 코드 제거

프로그램의 효율성을 향상시켜주지는 못함
 -프로그래머의 역량이 중요하데요

컴파일러의 최적화를 막는 요소
-memory aliasing
-procedure

컴파일러 최적화의 한계
	실행하는데에 있으서 있는 기본적인 한계
		-correctness  : 뭘하든 상관은 없지만 결과는 같게 나오게해라.
		-프로그램의 행동에 아무런 영향을 끼치지 못한다.
			(단, 아예 돌아가지 못하는 상황을  제외하고는)

		-컴파일러의 최적화의 범위가 procedure안에서 밖에 안된데(function 함수단위로만)
		(함수 밖까지 최적화를 해야한다 하면, 시간이 오래걸림)

		-static information 정적인 정보에만 의존하기에 한계점이 있다고.

컴파일러에서 보통 사용되는 최적화
	-루프안에 계산문을 넣어서 해놓으면 루프를 돌면서 계속 계산을 해주어야함.
	(여기서 루프문 밖에서 한번만 계산하게 해놓고 계속 불러서 씀);

	gcc 컴파일러를 쓸 때 gcc -o 결과물파일이름 컴파일할파일 
	이럴때 다른 옵션 o1이런식으로 넣어줄수있음.

	-곱하기/나누기를 더하기/shift연산으로 바꿔주는 것.

	-shell script = 컴파일러 없이 그냥 실행되는 script

	-같은 계산을 하는 것은 같은 곳에 넣어서 한꺼번에 계산하게한다.(-o1 옵션에서해줌)

최적화를 막는것
	-memory aliasing(메모리 레퍼런스를 써서 ->여러곳에서 메모리를 부른다.)
		memory access = 비싼 행동.
		물리적 주소가 같지만 이름만 다를 때(->*xp와 *yp의 주소가 같을때)
			(참조연산할 때 많이 발생함.)
		-해결법? 지역변수(local variables)를 많이 써라.
			->그러면 컴파일러가 memory aliasing을 확인할 필요가 없어짐.
		(지역변수는 레지스터에서 사용만되고 없어진다.?)

	-procedur call(side effect가 있는지 없는지를 알 수 없기 때문)
		-함수의 행동에 따라 달라지는 값이 있을 수 있기 때문이다
		(예를 들자면 함수가 호출된 횟수를 세고있는데, 4번 부른것과 1번부른것을 4배해준
		값의 출력값은 같지만 카운트해준 값이 달라질 수 있다.)
		(함수호출은 비용이 비싼 행동이기에 함수안의 내용을 알고 싶지 않기 때문에도 컴파일러가 마음대로 최적화시키지는 않는다.)

		-strlen:호출 할때마다 문자열을 모두 루프하기때문에 비싼 함수임.



	lambda function : 함수 블럭 자체를 다른 함수의 매개변수로 넘겨주는 방식.	
		(그때 그때 마다 tmp처럼 값을 변형할 수 있는)


